
## 지연 평가
- 지연 평가: 평가를 지연하는 것이고 함수를 이용해서 구현한다.

함수형 프로그래밍에서 추상화를 함수 단위로 하고 식과 값을 함수 단위로 다루면서 평가(실행)

**함수형 프로그래밍에서 중요한 것**
- 어떤 곳에서 함수를 선언할 수 있는지
- 어디에서 실행할 수 있는지
- 즉시 실행할 수 있는지
- 언제 실행할 수 있는지
- 함수를 또 다른 실행 컨텍스트로 넘겨 어떻게 이어갈 수 있는지


**Lodash의 체인 방식 지연 평가가 아쉬운 이유**

1. 평가 조건이 암시적이다. (length가 200개 이상, iteratee가 선언한 인자 개수가 1개여야 동작)

=> 즉, 조건이 아예 정적으로 구현되어 있어 커스텀을 할 수 없다. 따라서 명시적으로 지연 평가 조건을 전달할 수 없다.

2. 지연 평가할 메서드를 선택할 수 없다.

=> 함수의 순서 배치, 어디까지만 지연 평가를 적용할 지 커스텀이 불가능하다.


**Partial.js의 L 사용하기**

```js
_.go([2, 4, 11, 2, 7, 12],
  L.map(square), // 3번 반복 (6번에서 3번으로 줄어듬)
  L.every(v => v < 100), // 3번 반복
  console.log);
// false (총 6번 반복하여 결과를 얻음)

//(2) 위처럼 L로 바꾸었을 때, 내부적으로 동작하는 모습을 표현하면 아래와 같다.
_.go([2, 4, 11, 2, 7, 12],
  _.every(_.pipe(square, v => v < 100)), // 3번 반복
  console.log);
```


지연 평가의 3가지 기준은 다음과 같다.

1. 데이터가 많을 때
2. 앞쪽 함수가 무거운 함수일 때 
3. 뒤쪽으로 갈수록 필요한 재료가 적을 때


## 컬렉션 중심 프로그래밍

컬렉션 중심 프로그래밍의 목표는 컬렉션을 다루는 좋은 로직의 함수 세트를 만들어 재사용성을 극대화 하는 것이다.

4가지 유형별 대표 함수와 유형
- map - 순회하면서 새로운 값 만들기 (**수집하기**)
- fillter - 순회하면서 조건에 따라 필터링 (**거르기**)
- reduce - 순회하면서 좁히기 (**접기**)
- find - 순회하면서 조건에 맞는 결과를 완성하고 나가기 (**찾아내기**)
	- 모든 데이터를 순회할 필요가 없다.


### 수집하기, 거르기, 찾아내기와 지연 평가와의 연관성
`reduce` 지연 평가의 대상이 되지 않는다. 반드시 모두 순회를 해야 정상적인 값이 나오기 때문이다.

1. 수집하기, 거르기는 루프를 끝까지 돈다.
2. 수집하기, 거르기는 결과의 내부값을 만들기 위해 인자로 들어온 배열의 해당 번째 값만을 재료로 사용한다.

수집하기 -> 거르기 순으로 연속적인 함수 실행이라고 가정하자.

`[[수집하기, 수집하기], [거르기, 거르기]]` 와 `[[수집하기, 거르기], [수집하기, 거르기]]` 랑 동일한 결과값을 보여준다.

후자가 바로 지연 평가인 것이다.

Partial.js의 L을 사용한 지연 평가 예시이다.

```js
var list = [1, 2, 3, 4, 5, 6];
_.go(list,
  L.map(v => v * v),
  L.filter(v => v < 20),
  console.log);
// [1, 4, 9, 16]
```

`L.map->L.filter->L.take` 예시이다.
모든 데이터를 순회하지 않고 2번만 돌고 루프를 빠져나온다.

```js
var count = 0; // 루프 카운트
var list = [1, 2, 3, 4, 5, 6];
_.go(list,
  L.map(function(v) {
    count++;
    return v * v;
  }),
  L.filter(v => v < 20),
  L.take(2),
  console.log);
// [1, 4]

console.log(count);
// 2 (2번만 반복)
```
